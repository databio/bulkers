#!/usr/bin/env python3
"""Mock executable for '{{ command }}' - replays pre-recorded outputs."""
import json
import os
import re
import sys
from pathlib import Path

COMMAND = "{{ command }}"

def main():
    outputs_file = os.environ.get("BULKER_MOCK_OUTPUTS")
    if not outputs_file:
        print(f"BULKER_MOCK_OUTPUTS not set; cannot replay mock for '{COMMAND}'", file=sys.stderr)
        sys.exit(1)

    try:
        with open(outputs_file) as f:
            outputs = json.load(f)
    except (OSError, json.JSONDecodeError) as e:
        print(f"Failed to read mock outputs from {outputs_file}: {e}", file=sys.stderr)
        sys.exit(1)

    records = outputs.get(COMMAND, [])
    args_str = " ".join(sys.argv[1:])

    for record in records:
        pattern = record.get("args_pattern", ".*")
        if re.search(pattern, args_str):
            # Print stdout
            stdout = record.get("stdout", "")
            if stdout:
                sys.stdout.write(stdout)
                sys.stdout.flush()

            # Print stderr
            stderr = record.get("stderr", "")
            if stderr:
                sys.stderr.write(stderr)
                sys.stderr.flush()

            # Create files
            for rel_path, content in record.get("creates_files", {}).items():
                p = Path(rel_path)
                p.parent.mkdir(parents=True, exist_ok=True)
                if content == "PLACEHOLDER_BINARY":
                    p.write_bytes(b"\x00")
                else:
                    p.write_text(content)

            sys.exit(record.get("returncode", 0))

    # No matching record found
    print(f"No mock recording matches '{COMMAND}' with args: {args_str}", file=sys.stderr)
    sys.exit(1)

if __name__ == "__main__":
    main()
